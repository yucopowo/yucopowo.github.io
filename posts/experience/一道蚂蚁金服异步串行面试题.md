# 一道蚂蚁金服异步串行面试题

```javascript


const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const subFlow = createFlow([() => delay(1000).then(() => log("c"))]);

createFlow([
  () => log("a"),
  () => log("b"),
  subFlow,
  [() => delay(1000).then(() => log("d")), () => log("e")],
]).run(() => {
  console.log("done");
});

// 需要按照 a,b,延迟1秒,c,延迟1秒,d,e, done 的顺序打印


```

按照上面的测试用例，实现 createFlow：

flow 是指一系列 effects 组成的逻辑片段。
flow 支持嵌套。
effects 的执行只需要支持串行。



```javascript {demo type=module}

function Flow(effects = []) {
    this.tasks = effects.reduce((result, effect) => {
        if(effect instanceof Flow) {
            result.push(...effect.tasks);
        } else if(Array.isArray(effect)) {
            result.push(...effect);
        } else {
            result.push(effect);
        }
        return result;
    }, []);
}

Flow.prototype.run = function(callback) {
    return new Promise(async (resolve) => {
        for(let i = 0;i<this.tasks.length;i++) {
           const task = this.tasks[i];
           await task();
        }
        callback();
    });    
}


function createFlow(effects) {
    return new Flow(effects);
}

const log = console.log;

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const subFlow = createFlow([() => delay(1000).then(() => log("c"))]);

createFlow([
  () => log("a"),
  () => log("b"),
  subFlow,
  [() => delay(1000).then(() => log("d")), () => log("e")],
]).run(() => {
  console.log("done");
});


```
